---
id: aoc-2019
title: Advent of Code 2019
---

## Problem 1

[Problem link](https://adventofcode.com/2019/day/1)

### Part 1

Fuel required is `floor(mass / 3) - 2`.

```scala mdoc:invisible
val input1: List[Long] = List(
  100152,
  121802,
  140047,
  92337,
  101891,
  122051,
  50384,
  53628,
  139979,
  57959,
  90354,
  119201,
  53941,
  74563,
  140320,
  69972,
  90954,
  85414,
  52999,
  69869,
  65511,
  91084,
  146614,
  120976,
  145517,
  121313,
  99155,
  144062,
  53343,
  60992,
  81324,
  109565,
  83665,
  100255,
  116562,
  71967,
  66486,
  76844,
  83233,
  129089,
  98787,
  118848,
  120030,
  123908,
  144800,
  113563,
  74763,
  80902,
  58740,
  115929,
  57926,
  61739,
  118481,
  111540,
  55259,
  90161,
  110745,
  85103,
  92616,
  126402,
  71906,
  137282,
  76811,
  124470,
  140723,
  89796,
  98126,
  127274,
  104925,
  120395,
  134417,
  105281,
  140414,
  52683,
  149260,
  123259,
  125238,
  68860,
  103545,
  90308,
  118854,
  121111,
  72989,
  62993,
  96615,
  145935,
  75078,
  96752,
  118779,
  68090,
  95136,
  82132,
  149426,
  51496,
  70123,
  129725,
  63022,
  74422,
  143216,
  139349
)
```

```scala mdoc
def calcRequiredFuel(mass: Long): Long =
  (mass.toDouble / 3d).floor.toLong - 2

input1.map(calcRequiredFuel).sum
```

### Part 2

Recursively calculate the required fuel for each module, then
calculate the fuel required to carry that fuel recursively.
Negative fuel is treated as 0.

```scala mdoc
import scala.annotation.tailrec

def calcTotalFuel(origMass: Long): Long = {
  @tailrec
  def iter(mass: Long, totalFuel: Long): Long = {
    val fuel = calcRequiredFuel(mass).max(0)
    if (fuel == 0) totalFuel
    else iter(fuel, totalFuel + fuel)
  }
  iter(origMass, 0)
}

input1.map(calcTotalFuel).sum
```

## Problem 2

[Problem link](https://adventofcode.com/2019/day/2)

### Part 1

```scala mdoc:invisible:reset
val input2 = Vector(1,0,0,3,1,1,2,3,1,3,4,3,1,5,0,3,2,1,6,19,1,9,19,23,2,23,10,27,1,27,5,31,1,31,6,35,1,6,35,39,2,39,13,43,1,9,43,47,2,9,47,51,1,51,6,55,2,55,10,59,1,59,5,63,2,10,63,67,2,9,67,71,1,71,5,75,2,10,75,79,1,79,6,83,2,10,83,87,1,5,87,91,2,9,91,95,1,95,5,99,1,99,2,103,1,103,13,0,99,2,14,0,0)
```

```scala mdoc
import scala.annotation.tailrec

@tailrec
final def run(program: Vector[Int], pointer: Int): Vector[Int] = {
  program.slice(pointer, pointer + 4).toList match {
    case 99 :: _ => program
    case 1 :: address1 :: address2 :: updateAddress :: _ =>
      run(
        program.updated(updateAddress, program(address1) + program(address2)),
        pointer + 4)
    case 2 :: address1 :: address2 :: updateAddress :: _ =>
      run(
        program.updated(updateAddress, program(address1) * program(address2)),
        pointer + 4)
    case instruction =>
      throw new IllegalStateException(s"Unexpected instruction supplied ${instruction.mkString(",")} ($pointer)")
  }
}

run(input2.updated(1, 12).updated(2, 2), 0)(0)
```

### Part 2

```scala mdoc
def runProgram(program: Vector[Int], noun: Int, verb: Int): Int = {
  run(program.updated(1, noun).updated(2, verb), 0)(0)
}
```

Calculate all possible noun and verb combinations.

```scala mdoc:silent
val results = for {
  noun <- (1 to 99)
  verb <- (1 to 99)
  result = runProgram(input2, noun, verb)
} yield (noun, verb, result)
```

Get the first noun and verb combination that gives the correct result.

```scala mdoc
results
  .collectFirst { case (noun, verb, 19690720) => 100 * noun + verb }
  .get
```

## Problem 3

[Problem link](https://adventofcode.com/2019/day/3)

### Part 1

Coerce the strings into the required data. Keep track of the starting position
of each path segment.

```scala mdoc:reset-object
sealed trait PathSegment {
  def x: Int
  def y: Int
}
final case class Horizontal(x: Int, y: Int, dx: Int) extends PathSegment
final case class Vertical(x: Int, y: Int, dy: Int) extends PathSegment

object PathSegment {

  private val commandPattern = """([URDL])(\d+)""".r
  def unsafeFromString(s: String, x: Int, y: Int): PathSegment = {
    s match {
      case commandPattern("U", delta) => Vertical(x, y, delta.toInt)
      case commandPattern("R", delta) => Horizontal(x, y, delta.toInt)
      case commandPattern("D", delta) => Vertical(x, y, -delta.toInt)
      case commandPattern("L", delta) => Horizontal(x, y, -delta.toInt)
      case unknown => throw new IllegalArgumentException(s"Unexpected command string $unknown")
    }
  }
}

type Path = List[PathSegment]
object Path {
  def unsafeFromString(s: String): (Path, Path) = {
    val (line1, line2) = s.span(_ != '\n')
    (parsePathLine(line1), parsePathLine(line2.trim))
  }

  private def parsePathLine(s: String): Path = s
    .split(",")
    .toList
    .foldLeft((List.empty[PathSegment], 0, 0)) { case ((acc, x, y), segmentS) =>
      val segment = PathSegment.unsafeFromString(segmentS, x, y)
      segment match {
        case horizontal: Horizontal =>
          (horizontal :: acc, x + horizontal.dx, y)
        case vertical: Vertical =>
          (vertical :: acc, x, y + vertical.dy)
      }
    }
    ._1
    .reverse
}
```

For the problem the distinction between horizontal and vertical doesn't matter.
However it's much easier to visualize.

```scala mdoc
def findIntersectPoints(path1: Path, path2: Path) =
  for {
    segment1 <- path1
    segment2 <- path2
    point <- (segment1, segment2) match {
      case (_: Horizontal, _: Horizontal) => None
      case (_: Vertical, _: Vertical) => None
      case (horizontal: Horizontal, vertical: Vertical) =>
        findIntersectPoint(horizontal, vertical)
      case (vertical: Vertical, horizontal: Horizontal) =>
        findIntersectPoint(horizontal, vertical)
    }
  } yield point

def findIntersectPoint(
  horizontal: Horizontal,
  vertical: Vertical
): Option[(Int, Int)] = (horizontal, vertical) match {
  case (Horizontal(x1, y1, dx), Vertical(x2, y2, dy)) =>
    if (y1 < y2.max(y2 + dy) && y1 > y2.min(y2 + dy) &&
        x2 < x1.max(x1 + dx) && x2 > x1.min(x1 + dx)) {
      Some(x2 -> y1)
    } else None
}
```

```scala mdoc
def runPart1(s: String): Int = {
  val (path1, path2) = Path.unsafeFromString(s)
  findIntersectPoints(path1, path2)
    .map { case (x, y) => x.abs + y.abs }
    .min
}
```

Run the examples.

```scala mdoc
runPart1("""R75,D30,R83,U83,L12,D49,R71,U7,L72
U62,R66,U55,R34,D71,R55,D58,R83""")
runPart1("""R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51
U98,R91,D20,R16,D67,R40,U7,R15,U6,R7""")
```

Success!

```scala mdoc:invisible
val input3 = """R1000,U371,R195,U136,R804,U805,L450,U211,R768,U768,L548,U354,L736,U431,L152,U658,L670,D262,L277,U136,L290,U939,R501,U550,L931,D839,R335,D492,L25,U80,R878,U355,R653,U186,R423,D485,L793,D259,L739,U679,R508,D269,R432,D761,R97,D461,L675,U958,L58,U348,L719,D271,R144,U849,R384,U72,L84,U493,R947,U30,L356,D442,R327,U646,R825,U718,L329,D173,L949,D345,L971,D830,L93,U506,R245,D376,R322,D105,L604,D60,R298,D959,L165,D423,R180,D527,R956,D944,R785,U641,L794,D182,R975,D719,L166,U974,L224,U243,L666,U706,R796,D600,L856,D913,L988,D993,L259,U351,R487,D424,L335,U910,L437,D180,R621,D3,R878,D188,R254,D393,L727,U829,R352,U958,L327,D158,L854,D17,R143,D454,R889,D265,L345,U784,R35,D129,R77,U117,R951,D980,L866,U646,R242,D603,L562,U727,L496,U328,L380,D504,R644,U803,L530,D546,R328,D373,L489,U454,R74,D908,R366,U94,R604,D482,L573,D27,R943,U497,L782,D267,L391,U49,R528,D58,R155,D529,R227,D998,R558,D891,R224,U843,R512,U34,R92,U404,R752,U946,L338,D880,L513,D28,L856,D444,L187,U532,L187,U669,L306,U259,R287,D442,R478,U576,R702,U336,L305,U701,L754,D277,R760,D863,L717,U196,L221,U101,L334,D156,L961,D810,L67,D716,L457,D44,L505,D724,R716,D660,L36,D338,R54,U424,R730,U18,L65,D133,R149,U374,R356,D989,R519,U593,L444,D270,R328,U167,L748,D797,L434,U751,R444,D71,R158,D530,L630,U147,R909,D994,L957,U521,L644,D579,R673,U191,R935,U237,R600,D321,L671,U961,L884,U378,R534,D46,R275,U845,R571,U245,L507,U273,R995,U408,L14,D799,L955,D534,R579,D94,R705,D391,R469,D381,R620,U162,R907,D826,R824,U167,L734,U922,L484
L1007,D620,R853,U77,L13,U473,L253,D410,R897,U464,L862,U281,L650,D470,R87,D204,L896,U670,L864,D950,L75,D320,R901,D785,L653,D225,L857,U616,L143,U940,L664,U131,L547,D745,R636,U569,L50,U454,R288,D254,L36,U377,L609,U929,L714,U85,L939,U923,L566,D280,R243,U948,R447,D7,R908,D151,R824,D432,R34,D81,L458,U745,L420,D982,L625,U910,L729,D274,R910,U322,L984,D88,L700,D349,L932,U510,R625,U88,L252,U785,L378,D101,R299,U66,L476,U696,R236,D46,R590,U157,R461,U305,L269,D487,L676,U467,R319,D524,R75,U65,L478,U861,L238,D716,R888,D12,L184,D578,R266,D226,L656,D172,L752,U124,L831,U810,L663,U538,R417,D770,L359,U1,R12,U791,L332,U272,R574,D942,L857,U447,R310,U342,L713,D258,R590,D585,R129,D115,R832,D967,R981,D159,R864,U423,R268,U519,L52,D493,R445,D657,R885,U166,R155,D264,R51,D632,R525,D875,R617,U898,L556,D386,L143,U278,L767,D389,R821,U869,R286,D90,R289,U54,R15,D764,R46,D674,R983,U49,R959,U779,R958,D247,R483,U156,L18,U12,L178,U540,L499,U487,L544,D336,R814,U267,R145,D135,L920,D902,L933,D507,L997,U361,L577,U425,L773,D782,R117,U851,R998,U503,R902,U781,L161,U98,L653,U633,L91,U629,L138,D19,R147,D756,R364,D529,L764,U913,L118,U856,R774,D621,R151,U154,R737,D960,R86,U458,R991,D481,R560,D858,R223,D6,R931,D301,R552,D797,R284,U368,L967,D686,R940,U410,R137,D156,L6,U643,L445,D999,R888,D277,L852,U210,L777,D36,R103,D652,R120,D67,L642,D527,R913,D858,R69,D433,R864,U75,L531,U456,L664,D452,R801,U851,L824,D278,L526,U133,R200,U768,R15,U393,R982,U287,L38,D114,R86,U299,L819,D891,R379,D601,L244"""
```

```scala mdoc
runPart1(input3)
```

### Part 2

Modify the function in part 1 to return the segments which intersect,
making it easy to find the segments leading up to intersection.

```scala mdoc
final case class Intersect(
  segment1: PathSegment, segment2: PathSegment,
  x: Int, y: Int)

def findIntersects(path1: Path, path2: Path): List[Intersect] =
  for {
    segment1 <- path1
    segment2 <- path2
    intersect <- (segment1, segment2) match {
      case (_: Horizontal, _: Horizontal) => None
      case (_: Vertical, _: Vertical) => None
      case (horizontal: Horizontal, vertical: Vertical) =>
        findIntersectPoint(horizontal, vertical).map { case (x, y) =>
          Intersect(horizontal, vertical, x, y)
        }
      case (vertical: Vertical, horizontal: Horizontal) =>
        findIntersectPoint(horizontal, vertical).map { case (x, y) =>
          Intersect(vertical, horizontal, x, y)
        }
    }
  } yield intersect
```

Count the steps to the intersection, and add the distance to the intersection point.

```scala mdoc
def runPart2(s: String) = {
  val (path1, path2) = Path.unsafeFromString(s)
  val intersects = findIntersects(path1, path2)
  val stepCounts = intersects.map { case Intersect(segment1, segment2, x, y) =>
    val stepCount1 = countSteps(path1.takeWhile(_ != segment1)) +
      ((segment1.x - x).abs + (segment1.y - y).abs)
    val stepCount2 = countSteps(path2.takeWhile(_ != segment2)) +
      ((segment2.x - x).abs + (segment2.y - y).abs)
    stepCount1 + stepCount2
  }
  stepCounts.min
}

def countSteps(path: Path) = {
  path.foldLeft(0) {
    case (count, Horizontal(_, _, dx)) => count + dx.abs
    case (count, Vertical(_, _, dy)) => count + dy.abs
  }
}
```

Examples.

```scala mdoc
runPart2("""R75,D30,R83,U83,L12,D49,R71,U7,L72
U62,R66,U55,R34,D71,R55,D58,R83""")
runPart2("""R98,U47,R26,D63,R33,U87,L62,D20,R33,U53,R51
U98,R91,D20,R16,D67,R40,U7,R15,U6,R7""")
```

```scala mdoc
runPart2(input3)
```

## Problem 4

[Problem link](https://adventofcode.com/2019/day/4)

### Part 1

Apply the rule.

```scala mdoc:reset-object
import cats.implicits._

def isDescending(digits: List[Int]): Boolean =
  digits.foldM(0) {
    case (prev, curr) if curr < prev => None
    case (prev, curr) if curr >= prev => Some(curr)
  }.isDefined

def hasDoubleDigit(digits: List[Int]): Boolean =
  digits.foldM(0) {
    case (prev, curr) if prev == curr => None
    case (prev, curr) => Some(curr)
  }.isEmpty

def rule(digits: List[Int]): Boolean =
  isDescending(digits) && hasDoubleDigit(digits)
```

Test the examples.

```scala mdoc
import scala.annotation.tailrec

def digits(i: Int): List[Int] = {
  @tailrec
  def loop(n: Int, acc: List[Int]): List[Int] = {
    if (n == 0) acc
    else {
      val x = (n / 10) * 10
      loop(x / 10, n - x :: acc)
    }
  }
  loop(i, List.empty)
}

// get digits and put in list
digits(12345678)

assert(rule(digits(111111)) == true)
assert(rule(digits(223450)) == false)
assert(rule(digits(123789)) == false)
```

Let's try brute forcing.

```scala mdoc
(145852 to 616942).count(i => rule(digits(i)))
```

Looks like it completes in a sensible amount of time!

### Part 2

```scala mdoc
def hasOnlyDoubleDigit(digits: List[Int]): Boolean =
  digits
    .foldM((1, 0)) {
      case ((combo, prev), curr) if prev == curr => Some((combo + 1, curr))
      case ((2, prev), curr) if prev != curr => None
      case ((_, prev), curr) if prev != curr => Some((1, curr))
    }
    .map {
      case (2, _) => true
      case _ => false
    }
    .getOrElse(true)

def newRule(digits: List[Int]): Boolean =
  isDescending(digits) && hasOnlyDoubleDigit(digits)
```

Examples.

```scala mdoc
assert(newRule(digits(112233)) == true)
assert(newRule(digits(123444)) == false)
assert(newRule(digits(111122)) == true)
assert(newRule(digits(111111)) == false)
```

```scala mdoc
(145852 to 616942).count(i => newRule(digits(i)))
```

## Problem 5

[Problem link](https://adventofcode.com/2019/day/5)

### Part 1

```scala mdoc:invisible:reset-object
val input5 = Vector(3, 225, 1, 225, 6, 6, 1100, 1, 238, 225, 104, 0, 1101, 37, 34, 224, 101, -71, 224, 224, 4, 224, 1002, 223, 8, 223, 101, 6, 224, 224, 1, 224, 223, 223, 1002, 113, 50, 224, 1001, 224, -2550, 224, 4, 224, 1002, 223, 8, 223, 101, 2, 224, 224, 1, 223, 224, 223, 1101, 13, 50, 225, 102, 7, 187, 224, 1001, 224, -224, 224, 4, 224, 1002, 223, 8, 223, 1001, 224, 5, 224, 1, 224, 223, 223, 1101, 79, 72, 225, 1101, 42, 42, 225, 1102, 46, 76, 224, 101, -3496, 224, 224, 4, 224, 102, 8, 223, 223, 101, 5, 224, 224, 1, 223, 224, 223, 1102, 51, 90, 225, 1101, 11, 91, 225, 1001, 118, 49, 224, 1001, 224, -140, 224, 4, 224, 102, 8, 223, 223, 101, 5, 224, 224, 1, 224, 223, 223, 2, 191, 87, 224, 1001, 224, -1218, 224, 4, 224, 1002, 223, 8, 223, 101, 4, 224, 224, 1, 224, 223, 223, 1, 217, 83, 224, 1001, 224, -124, 224, 4, 224, 1002, 223, 8, 223, 101, 5, 224, 224, 1, 223, 224, 223, 1101, 32, 77, 225, 1101, 29, 80, 225, 101, 93, 58, 224, 1001, 224, -143, 224, 4, 224, 102, 8, 223, 223, 1001, 224, 4, 224, 1, 223, 224, 223, 1101, 45, 69, 225, 4, 223, 99, 0, 0, 0, 677, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1105, 0, 99999, 1105, 227, 247, 1105, 1, 99999, 1005, 227, 99999, 1005, 0, 256, 1105, 1, 99999, 1106, 227, 99999, 1106, 0, 265, 1105, 1, 99999, 1006, 0, 99999, 1006, 227, 274, 1105, 1, 99999, 1105, 1, 280, 1105, 1, 99999, 1, 225, 225, 225, 1101, 294, 0, 0, 105, 1, 0, 1105, 1, 99999, 1106, 0, 300, 1105, 1, 99999, 1, 225, 225, 225, 1101, 314, 0, 0, 106, 0, 0, 1105, 1, 99999, 7, 226, 226, 224, 102, 2, 223, 223, 1005, 224, 329, 101, 1, 223, 223, 108, 677, 226, 224, 102, 2, 223, 223, 1005, 224, 344, 1001, 223, 1, 223, 1108, 226, 677, 224, 102, 2, 223, 223, 1005, 224, 359, 1001, 223, 1, 223, 8, 677, 226, 224, 102, 2, 223, 223, 1006, 224, 374, 1001, 223, 1, 223, 107, 226, 226, 224, 102, 2, 223, 223, 1006, 224, 389, 101, 1, 223, 223, 1108, 677, 226, 224, 1002, 223, 2, 223, 1005, 224, 404, 1001, 223, 1, 223, 108, 677, 677, 224, 102, 2, 223, 223, 1005, 224, 419, 101, 1, 223, 223, 7, 226, 677, 224, 1002, 223, 2, 223, 1006, 224, 434, 1001, 223, 1, 223, 107, 226, 677, 224, 102, 2, 223, 223, 1005, 224, 449, 101, 1, 223, 223, 1108, 677, 677, 224, 1002, 223, 2, 223, 1006, 224, 464, 101, 1, 223, 223, 7, 677, 226, 224, 102, 2, 223, 223, 1006, 224, 479, 101, 1, 223, 223, 1007, 677, 677, 224, 1002, 223, 2, 223, 1005, 224, 494, 101, 1, 223, 223, 1008, 226, 226, 224, 102, 2, 223, 223, 1006, 224, 509, 1001, 223, 1, 223, 107, 677, 677, 224, 102, 2, 223, 223, 1006, 224, 524, 1001, 223, 1, 223, 8, 226, 226, 224, 1002, 223, 2, 223, 1005, 224, 539, 1001, 223, 1, 223, 1007, 677, 226, 224, 102, 2, 223, 223, 1006, 224, 554, 1001, 223, 1, 223, 1007, 226, 226, 224, 1002, 223, 2, 223, 1005, 224, 569, 1001, 223, 1, 223, 8, 226, 677, 224, 1002, 223, 2, 223, 1006, 224, 584, 101, 1, 223, 223, 108, 226, 226, 224, 1002, 223, 2, 223, 1006, 224, 599, 101, 1, 223, 223, 1107, 677, 226, 224, 1002, 223, 2, 223, 1005, 224, 614, 1001, 223, 1, 223, 1107, 226, 677, 224, 102, 2, 223, 223, 1006, 224, 629, 1001, 223, 1, 223, 1008, 226, 677, 224, 102, 2, 223, 223, 1005, 224, 644, 101, 1, 223, 223, 1107, 226, 226, 224, 102, 2, 223, 223, 1006, 224, 659, 1001, 223, 1, 223, 1008, 677, 677, 224, 102, 2, 223, 223, 1006, 224, 674, 1001, 223, 1, 223, 4, 223, 99, 226)
```

Simplify the interpreter by using `Instruction` ADT.

```scala mdoc
import cats.implicits._
import scala.annotation.tailrec

sealed trait ParamMode

object ParamMode {
  case object Position extends ParamMode
  case object Immediate extends ParamMode

  def unapply(i: Int): Option[ParamMode] = i match {
    case 0 => Position.some
    case 1 => Immediate.some
    case _ => None
  }
}

final case class Params(
  opCode: Int,
  param1: ParamMode, param2: ParamMode, param3: ParamMode)

object Params {

  def fromInt(i: Int): Option[Params] = {
    digits(i).reverse match {
      case d :: e :: ParamMode(c) :: ParamMode(b) :: ParamMode(a) :: Nil =>
        Params(d + e * 10, c, b, a).some
      case d :: e :: ParamMode(c) :: ParamMode(b) :: Nil =>
        Params(d + e * 10, c, b, ParamMode.Position).some
      case d :: e :: ParamMode(c) :: Nil =>
        Params(d + e * 10, c, ParamMode.Position, ParamMode.Position).some
      case d :: e :: Nil =>
        Params(d + e * 10, ParamMode.Position, ParamMode.Position, ParamMode.Position).some
      case d :: Nil =>
        Params(d, ParamMode.Position, ParamMode.Position, ParamMode.Position).some
      case _ => None
    }
  }

  private def digits(i: Int): List[Int] = {
    @tailrec
    def loop(n: Int, acc: List[Int]): List[Int] = {
      if (n == 0) acc
      else {
        val x = (n / 10) * 10
        loop(x / 10, n - x :: acc)
      }
    }
    loop(i, List.empty)
  }
}

sealed trait Instruction
case object Halt extends Instruction
final case class Add(arg1: Int, param1: ParamMode, arg2: Int, param2: ParamMode, address: Int) extends Instruction
final case class Mult(arg1: Int, param1: ParamMode, arg2: Int, param2: ParamMode, address: Int) extends Instruction
final case class In(address: Int) extends Instruction
final case class Out(arg1: Int, param1: ParamMode) extends Instruction
final case class JumpIfTrue(arg1: Int, param1: ParamMode, pointer: Int, param2: ParamMode) extends Instruction
final case class JumpIfFalse(arg1: Int, param1: ParamMode, pointer: Int, param2: ParamMode) extends Instruction
final case class LessThan(arg1: Int, param1: ParamMode, arg2: Int, param2: ParamMode, address: Int) extends Instruction
final case class Equals(arg1: Int, param1: ParamMode, arg2: Int, param2: ParamMode, address: Int) extends Instruction

object Instruction {
  def fromList(l: List[Int]): Option[Instruction] =
    (l.headOption.flatMap(Params.fromInt), l.tail) match {
      case (Some(Params(99, _, _, _)),  _) => Halt.some
      case (Some(Params(1, param1, param2, _)), arg1 :: arg2 :: arg3 :: Nil) =>
        Add(arg1, param1, arg2, param2, arg3).some
      case (Some(Params(2, param1, param2, _)), arg1 :: arg2 :: arg3 :: Nil) =>
        Mult(arg1, param1, arg2, param2, arg3).some
      case (Some(Params(3, _, _, _)), arg1 :: _) => In(arg1).some
      case (Some(Params(4, param1, _, _)), arg1 :: _) => Out(arg1, param1).some
      case (Some(Params(5, param1, param2, _)), arg1 :: arg2 :: _) =>
        JumpIfTrue(arg1, param1, arg2, param2).some
      case (Some(Params(6, param1, param2, _)), arg1 :: arg2 :: _) =>
        JumpIfFalse(arg1, param1, arg2, param2).some
      case (Some(Params(7, param1, param2, _)), arg1 :: arg2 :: arg3 :: _) =>
        LessThan(arg1, param1, arg2, param2, arg3).some
      case (Some(Params(8, param1, param2, _)), arg1 :: arg2 :: arg3 :: _) =>
        Equals(arg1, param1, arg2, param2, arg3).some
      case _ => None
    }
}

```

Write a program interpreter.

```scala mdoc
@tailrec
def runLoop(
  memory: Vector[Int],
  pointer: Int,
  inputs: List[Int],
  outputs: List[Int]
): List[Int] = {
  val instructionList = memory.slice(pointer, pointer + 4).toList
  Instruction.fromList(instructionList) match {
    case Some(Halt) => outputs
    case Some(Add(arg1, param1, arg2, param2, address)) =>
      val newMemory = memory.updated(address, resolveArg(memory, arg1, param1) + resolveArg(memory, arg2, param2))
      runLoop(newMemory, pointer + 4, inputs, outputs)
    case Some(Mult(arg1, param1, arg2, param2, address)) =>
      val newMemory = memory.updated(address, resolveArg(memory, arg1, param1) * resolveArg(memory, arg2, param2))
      runLoop(newMemory, pointer + 4, inputs, outputs)
    case Some(In(address)) =>
      val newMemory = memory.updated(address, inputs.head)
      runLoop(newMemory, pointer + 2, inputs.tail, outputs)
    case Some(Out(arg, param)) =>
      runLoop(memory, pointer + 2, inputs, resolveArg(memory, arg, param) :: outputs)
    case Some(JumpIfTrue(arg1, param1, newPointer, param2)) if resolveArg(memory, arg1, param1) != 0 =>
      runLoop(memory, resolveArg(memory, newPointer, param2), inputs, outputs)
    case Some(JumpIfTrue(arg, param, _, _)) if resolveArg(memory, arg, param) == 0 =>
      runLoop(memory, pointer + 3, inputs, outputs)
    case Some(JumpIfFalse(arg1, param1, newPointer, param2)) if resolveArg(memory, arg1, param1) == 0 =>
      runLoop(memory, resolveArg(memory, newPointer, param2), inputs, outputs)
    case Some(JumpIfFalse(arg, param, _, _)) if resolveArg(memory, arg, param) != 0 =>
      runLoop(memory, pointer + 3, inputs, outputs)
    case Some(LessThan(arg1, param1, arg2, param2, address)) =>
      val newMemory = memory.updated(
        address,
        if (resolveArg(memory, arg1, param1) < resolveArg(memory, arg2, param2)) 1 else 0
      )
      runLoop(newMemory, pointer + 4, inputs, outputs)
    case Some(Equals(arg1, param1, arg2, param2, address)) =>
      val newMemory = memory.updated(
        address,
        if (resolveArg(memory, arg1, param1) == resolveArg(memory, arg2, param2)) 1 else 0
      )
      runLoop(newMemory, pointer + 4, inputs, outputs)
    case None =>
      throw new IllegalStateException(s"Unexpected instruction supplied ${instructionList.mkString(",")} ($pointer)")
  }
}

def resolveArg(memory: Vector[Int], arg: Int, paramMode: ParamMode): Int =
  paramMode match {
    case ParamMode.Position => memory(arg)
    case ParamMode.Immediate => arg
  }

def run(program: Vector[Int], inputs: List[Int]): List[Int] =
  runLoop(program, 0, inputs, List.empty)
```

Run the program with 1 input.

```scala mdoc
run(input5, List(1))
```

### Part 2

Examples.

```scala mdoc:silent
val exampleInput = "3,21,1008,21,8,20,1005,20,22,107,8,21,20,1006,20,31,1106,0,36,98,0,0,1002,21,125,20,4,20,1105,1,46,104,999,1105,1,46,1101,1000,1,20,4,20,1105,1,46,98,99"
  .split(",")
  .map(_.toInt)
  .toVector
```

```scala mdoc
run(exampleInput, List(1))
run(exampleInput, List(8))
run(exampleInput, List(9))
```

Actual output.

```scala mdoc
run(input5, List(5))
```
