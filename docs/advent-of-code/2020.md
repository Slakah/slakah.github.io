---
id: aoc-2020
title: Advent of Code 2020
---

```scala mdoc:invisible
import aoc2020.Inputs._
```

## Problem 1

[Problem link](https://adventofcode.com/2020/day/1)

### Part 1

Calculate the difference between 2020 and the candidate number, lookup that value in the input. If we see the number in the input, it means we have a pair.

```scala mdoc
import cats.implicits._

def find2Addends(numbers: List[Long], target: Long): Option[(Long, Long)] = {
  val numSet = numbers.toSet
  numbers.collectFirstSome { x =>
    val y = target - x
    if (numSet(y)) Some((x, y))
    else None
  }
}

val (x, y) = find2Addends(input1, 2020L).get
x * y
```

### Part 2

Use recursion to find n addends which sum to a target value.

```scala mdoc
def findNAddends(numbers: List[Long], target: Long, n: Long): Option[List[Long]] = {
  n match {
    case 2 => find2Addends(numbers, target).map { case (x, y) => List(x, y) }
    case _ =>
      def loop(l: List[Long]): Option[List[Long]] = {
        l match {
          case x :: rest =>
            findNAddends(rest, target - x, n - 1) match {
              case None => loop(rest)
              case Some(addends) => Some(x :: addends)
            }
          case Nil => None
        }
      }
      loop(numbers)
  }
}

val addends = findNAddends(input1, 2020L, 3).get
addends.foldLeft(1L)(_ * _)
```

## Problem 2

[Problem link](https://adventofcode.com/2020/day/2)

### Part 1

Let's define the interesting bits we want from the input.

```scala mdoc
case class Rule(num1: Int, num2: Int, char: Char)
case class Line(rule: Rule, password: String)
```

Now use cats-parse to parse the input.

```scala mdoc
// here's the first few lines
println(input2.split("\n").take(5).mkString("\n"))
```

```scala mdoc:silent
import cats.parse.{Parser => P, _}

val parser = {
  val digits = Numbers.digits1.map(_.toInt)
  val alphaLower = P.charIn('a' to 'z')
  val rule = (digits ~ (P.char('-') *> digits) ~ (P.char(' ') *> alphaLower))
    .map { case ((num1, num2), char) => Rule(num1, num2, char) }

  val line = (rule ~ (P.string1(": ") *> alphaLower.rep1.string))
    .map { case (rule, password) =>
      Line(rule, password)
    }

  (line <* P.char('\n').orElse(P.end)).rep1
}
```

```scala mdoc
val lines = parser.parseAll(input2)
```

Now apply the rule to the passwords.

```scala mdoc
lines.map(_.count { case Line(rule, password) =>
  val count = password.count(_ === rule.char)
  (rule.num1 to rule.num2).contains(count)
})
```

### Part 2

Apply the new rule.

```scala mdoc
lines.map(_.count { case Line(rule, password) =>
  val first = password.lift(rule.num1 - 1).contains_(rule.char)
  val second = password.lift(rule.num2 - 1).contains_(rule.char)
  (first, second) match {
    case (true, true) => false
    case (true, false) => true
    case (false, true) => true
    case (false, false) => false
  }
})
```

## Problem 3

[Problem link](https://adventofcode.com/2020/day/3)

### Part 1

Describe the grid, with open and tree cells.

```scala mdoc
sealed trait Cell
case object Open extends Cell
case object Tree extends Cell

type Grid[A] = Array[Array[A]]
```

Let's parse the input:

```scala mdoc:silent
def parseGrid(s: String): Grid[Cell] = {
  s.split("\n").map { line =>
    line.map {
      case '.' => Open
      case '#' => Tree
    }.toArray[Cell]
  }.toArray
}

val s = """..##.......
#...#...#..
.#....#..#.
..#.#...#.#
.#...##..#.
..#.##.....
.#.#.#....#
.#........#
#.##...#...
#...##....#
.#..#...#.#"""

```

```scala mdoc
val grid = parseGrid(s)
```

Now let's render the grid to help debug.

```scala mdoc
import $ivy.`org.typelevel::cats-core:2.3.0`
import cats.implicits._
import cats.Show

object Cell {
  implicit def showCell[A <: Cell]: Show[A] = {
    case Open => "."
    case Tree => "#"
  }
}

def showGrid[A : Show](grid: Grid[A]) =
  grid.toList
    .map(line => line.toList.mkString_(""))
    .mkString_("\n")

println(showGrid(grid))
```

A function to produce a path down the slope.

```scala mdoc
import scala.annotation.tailrec

def downTheSlope(grid: Grid[Cell], xDelta: Int, yDelta: Int): List[(Int, Int, Cell)] = {
  val width = grid(0).size
  val height = grid.size
  @tailrec
  def loop(prevX: Int, prevY: Int, visited: List[(Int, Int, Cell)]): List[(Int, Int, Cell)] = {
    val x = (prevX + xDelta) % width
    val y = prevY + yDelta
    if (y >= height) visited
    else {
      val cell = grid(y)(x)
      loop(x, y, (x, y, cell) :: visited)
    }
  }
  loop(0, 0, Nil)
}
```

Overlay the path on the grid, with an overlay of visited cells, `.` as open, `#` as a tree.

```scala mdoc

def overlayPath(grid: Grid[Cell], path: List[(Int, Int, Cell)]): Grid[String] = {
  val coord2cell = path.map { case (x, y, cell) => ((x, y), cell) }.toMap
  grid.zipWithIndex.map { case (line, j) =>
    line.zipWithIndex.map { case (cell, i) =>
      (coord2cell.get((i, j)), cell) match {
        case (Some(Open), _) => "O"
        case (Some(Tree), _) => "X"
        case (None, Open) => "."
        case (None, Tree) => "#"
      }
    }
  }
}

println(showGrid(overlayPath(grid, downTheSlope(grid, 3, 1))))
```

This looks correct, now let's do it for the actual input.

```scala mdoc
downTheSlope(parseGrid(input3), 3, 1).count(_._3 == Tree)
```

### Part 2

Same again, for different trajectories, timesing by all the count of trees.

```scala mdoc
val slopes = List((1, 1), (3, 1), (5, 1), (7, 1), (1, 2))

slopes
  .map { case (xDelta, yDelta) =>
    downTheSlope(parseGrid(input3), 3, 1).count(_._3 == Tree).toLong
  }
  .foldLeft(1L)(_ * _)
```